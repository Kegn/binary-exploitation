# Csaw 2018 Tour of x86 pt 1

notes from [guyinatuxedo](https://guyinatuxedo.github.io/03-beginner_re/csaw18_x86tour_pt1/index.html)

First, grab the ```stage1.asm``` file from [github](https://github.com/mohamedaymenkarmous/CTF/tree/master/CSAWCTFQualificationRound2018/resources/reversing-50-a_tour_of_x86_part_1)

Now Let's look at the questions regarding this file on the [github page](https://github.com/mohamedaymenkarmous/CTF/tree/master/CSAWCTFQualificationRound2018#a-tour-of-x86---part-1)


### Question 1 : What is the value of dh after line 129 executes? (Answer with a one-byte hex value, prefixed with '0x')

Line 129 of the file is:
```asm
xor dh, dh  ; <- Question 1
```
The command is xoring the ```dh1``` register with itself, and storing the value in the ```dh``` register. When xoring something by itself, the result will be 0. So the value is ```0x0``` after line 129 executes.

### Question 2 : What is the value of gs after line 145 executes? (Answer with a one-byte hex value, prefixed with '0x')

Line 145 of the files is:
```asm
mov gs, dx ; to use them to help me clear     <- Question 2
```
The ```mov``` instruction here is moving the contents of the ```dx``` register into the ```gs``` register. To see what is in the ```ds``` register we look up a bit in the code (lines 131 and 132).
```asm
mov dx, 0xffff  ; Hexadecimal
not dx
```

We see that ```0xffff``` is moved into the ```dx``` register. After that, ```not``` is run on the register. This flops all the bits. Since the value is ```0xffff``` (all 1's), the result is ```0x0```. Since the register does not change all the way down to line 145, we know that the value ```0x0``` will get moved into the ``gs``` register.

### Question 3 : What is the value of si after line 151 executes? (Answer with a two-byte hex value, prefixed with '0')

Line 151 of the file is:
```asm
mov si, sp ; Source Index       <- Question 3
```
The ```mov``` instruction is moving the value of ```sp```, the value of **Stack Pointer** register into the ```si``` register, the **Source Index** register. We need to find the value of ```sp```. Looking up in the code we see on line 149:
```asm
mov sp, cx ; Stack Pointer
```
We now know that the value of the ```sp``` register is equal to the value of the ```cx``` register. Looking further up the code we see on Line 144:
```asm
mov fs, cx ; already zero, I'm just going
```
It says this is already zero. We look up again in the code to line 107:
```asm
mov cx, 0 ; The other two values get overwritten regardless, the value of ch and cl (the two components that make up cx) after this instruction are both 0, not 1.
```
So we know the value assigned to the ```si``` register will be ```0x0```.

### Question 4 : What is the value of ax after line 169 executes? (Answer with a two-byte hex value, prefixed with '0x')
We look at lines 168 and 169:
```asm
mov al, 't'
mov ah, 0x0e      ; <- question 4
```
This moves the value ```0x0e``` into the ```ah``` register and moves the value ```0x74``` (hex for ```t```) into the ```al``` register.

The questions asks about the ```ax``` register, which is a ```16-bit``` register, comprised of the two ```8-bit``` registers ```al``` and ```ah```.
```
 15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                       |                       |
|           AH          |           AL          |
|                       |                       |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```
The lower 8 bits are comprised of the ```al``` register. The higher 8 bits are comprised of the ```ah``` register.
Since the ```al``` register is equal to ```0x74``` and the ```ah``` register is equal to ```0x0e```, the ```ax``` register is equal to ```0x0e74```

### Question 5 : What is the value of ax after line 199 executes for the first time? (Answer with a two-byte hex value, prefixed with '0x')

We look at line 199:
```asm
mov ah, 0x0e  ; <- Question 5!
```
We know from the previous question that we only have half of the value needed for this register, the higher bits. We find the the assignment of the ```al``` register on line 197:
```asm
mov al, [si]  ; Since this is treated as a dereference of si, we are getting the BYTE AT si... `al = \*si`
```
We see here that dereferenced value of ```si``` is moved into the register ```al```. Now we need to find the value that ```si``` is pointing to.
We see this on line 189:
```asm
mov si, ax  ; We have no syntactic way of passing parameters, so I'm just going to pass the first argument of a function through ax - the string to print.
```
So the contents of ```ax``` is moved into ```si```. Line 179 and 180:
```asm
; First let's define a string to print, but remember...now we're defining junk data in the middle of code, so we need to jump around it so there's no attempt to decode our text string
mov ax, .string_to_print
```
Now we need to look for the string, found on line 182:
```asm
string_to_print: db "acOS", 0x0a, 0x0d, "  by Elyk", 0x00  ; label: <size-of-elements> <array-of-elements>
```
We also see that our line in question resides in a loop that prints the string:
```asm
; Now let's make a whole 'function' that prints a string
print_string:
  .init:
    mov si, ax  ; We have no syntactic way of passing parameters, so I'm just going to pass the first argument of a function through ax - the string to print.

  .print_char_loop:
    cmp byte [si], 0  ; The brackets around an expression is interpreted as "the address of" whatever that expression is.. It's exactly the same as the dereference operator in C-like languages
                        ; So in this case, si is a pointer (which is a copy of the pointer from ax (line 183), which is the first "argument" to this "function", which is the pointer to the string we are try    ing to print)
                        ; If we are currently pointing at a null-byte, we have the end of the string... Using null-terminated strings (the zero at the end of the string definition at line 178)
    je .end

    mov al, [si]  ; Since this is treated as a dereference of si, we are getting the BYTE AT si... `al = \*si`

    mov ah, 0x0e  ; <- Question 5!
    int 0x10      ; Actually print the character

    inc si        ; Increment the pointer, get to the next character
    jmp .print_char_loop
    .end:
```

This loop prints each character of the string. At the start, the pointer starts at the beginning of the string (line 197) and gets incremented (line 202) by one, meaning it moves to the next character until it hits a null byte ```0x0```. The comparison happens at line 192. Since the first character of the string is ```a``` which is ```0x61``` in hex, the value of the ```al``` register the first time it runs is ```0x61```. Putting this with our ```ah``` register, we get the valuew ```0x0e61```.


