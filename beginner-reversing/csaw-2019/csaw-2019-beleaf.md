# Csaw 2019 beleaf

notes from [guyinatuxedo](https://guyinatuxedo.github.io/03-beginner_re/csaw19_beleaf/index.html)

We can run ```file``` to get information about the binary.
```
$   file beleaf
beleaf: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=6d305eed7c9bebbaa60b67403a6c6f2b36de3ca4, stripped
```
We can also run ```pwn checksec``` on the binary.
```
$   pwn checksec beleaf
[*] '/root/github/binary-exploitation/beginner-reversing/csaw-2019/beleaf'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```
We run the file
```
$	./beleaf
Enter the flag
>>> 12345
Incorrect!
```

We see that we are dealing with a ```64-bit``` binary. The goal seems to be to pass it the correct input to pass the check it does.

## Reversing

Let's look at file in ghidra. This is our main function:
```c
undefined8 FUN_001008a1(void)

{
  size_t sVar1;
  long lVar2;
  long in_FS_OFFSET;
  ulong local_b0;
  char local_98 [136];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  printf("Enter the flag\n>>> ");
  __isoc99_scanf(&DAT_00100a78,local_98);
  sVar1 = strlen(local_98);
  if (sVar1 < 0x21) {
    puts("Incorrect!");
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  local_b0 = 0;
  while (local_b0 < sVar1) {
    lVar2 = FUN_001007fa((ulong)(uint)(int)local_98[local_b0]);
    if (lVar2 != *(long *)(&DAT_003014e0 + local_b0 * 8)) {
      puts("Incorrect!");
                    /* WARNING: Subroutine does not return */
      exit(1);
    }
    local_b0 = local_b0 + 1;
  }
  puts("Correct!");
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```
We clean up the names in ghidra:
```c
undefined8 main(void)

{
  size_t inputLen;
  long transformedInput;
  long in_FS_OFFSET;
  ulong i;
  char input [136];
  long stackCanary;
  
  stackCanary = *(long *)(in_FS_OFFSET + 0x28);
  printf("Enter the flag\n>>> ");
  __isoc99_scanf(&DAT_00100a78,input);
  inputLen = strlen(input);
  if (inputLen < 0x21) {
    puts("Incorrect!");
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  i = 0;
  while (i < inputLen) {
    transformedInput = transformFunc((ulong)(uint)(int)input[i]);
    if (transformedInput != *(long *)(&desiredOutput + i * 8)) {
      puts("Incorrect!");
                    /* WARNING: Subroutine does not return */
      exit(1);
    }
    i = i + 1;
  }
  puts("Correct!");
  if (stackCanary != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```
So we see that it starts off by scanning in input. If our input is less than ```0x21``` (33 bytes), the code exits. So our code probably needs to be 33 bytes.
It then enters a loop, passing each ```input[i]``` into the ```tranformFunc``` until it hits the exit condition.
It then compares the output to the against the corresponding char in the bss array ```desiredOutput```. If they are not equal, ```exit``` is called.

We inspect desiredOutput:
```
                             desiredOutput                                   XREF[2]:     main:0010096b(*), 
                                                                                          main:00100972(R)  
        003014e0 01              ??         01h
        003014e1 00              ??         00h
        003014e2 00              ??         00h
        003014e3 00              ??         00h
        003014e4 00              ??         00h
        003014e5 00              ??         00h
        003014e6 00              ??         00h
        003014e7 00              ??         00h
        003014e8 09              ??         09h
        003014e9 00              ??         00h
        003014ea 00              ??         00h
        003014eb 00              ??         00h
        003014ec 00              ??         00h
        003014ed 00              ??         00h
        003014ee 00              ??         00h
        003014ef 00              ??         00h
        003014f0 11              ??         11h
        003014f1 00              ??         00h
        003014f2 00              ??         00h
        003014f3 00              ??         00h
        003014f4 00              ??         00h
        003014f5 00              ??         00h
        003014f6 00              ??         00h
        003014f7 00              ??         00h
        003014f8 27              ??         27h    '
        003014f9 00              ??         00h
        003014fa 00              ??         00h
        003014fb 00              ??         00h
        003014fc 00              ??         00h
        003014fd 00              ??         00h
        003014fe 00              ??         00h
        003014ff 00              ??         00h
        00301500 02              ??         02h
```

We see that out first output has to be equal to ```0x1```, our second has to be ```0x9```, our third ```0x11``, etc...

We look at ```tranformFunc```:
```c
long transformFunc(char input)

{
  long i;
  
  i = 0;
  while ((i != -1 && ((int)input != *(int *)(&lookup + i * 4)))) {
    if ((int)input < *(int *)(&lookup + i * 4)) {
      i = i * 2 + 1;
    }
    else {
      if (*(int *)(&lookup + i * 4) < (int)input) {
        i = (i + 1) * 2;
      }
    }
  }
  return i;
}
```
We see that it takes a char and looks at what the index is in the ```lookup``` bss array. The chars are stored at offsets of 4 bytes. Here is the array:
```
                             lookup                                          XREF[6]:     transformFunc:00100820(*), 
                                                                                          transformFunc:00100827(R), 
                                                                                          transformFunc:00100844(*), 
                                                                                          transformFunc:0010084b(R), 
                                                                                          transformFunc:00100873(*), 
                                                                                          transformFunc:0010087a(R)  
        00301020 77              ??         77h    w
        00301021 00              ??         00h
        00301022 00              ??         00h
        00301023 00              ??         00h
        00301024 66              ??         66h    f
        00301025 00              ??         00h
        00301026 00              ??         00h
        00301027 00              ??         00h
        00301028 7b              ??         7Bh    {
        00301029 00              ??         00h
        0030102a 00              ??         00h
        0030102b 00              ??         00h
        0030102c 5f              ??         5Fh    _
        0030102d 00              ??         00h
        0030102e 00              ??         00h
        0030102f 00              ??         00h
        00301030 6e              ??         6Eh    n
        00301031 00              ??         00h
        00301032 00              ??         00h
        00301033 00              ??         00h
        00301034 79              ??         79h    y
        00301035 00              ??         00h
        00301036 00              ??         00h
        00301037 00              ??         00h
        00301038 7d              ??         7Dh    }
        00301039 00              ??         00h
        0030103a 00              ??         00h
        0030103b 00              ??         00h
        0030103c ff              ??         FFh
        0030103d ff              ??         FFh
        0030103e ff              ??         FFh
        0030103f ff              ??         FFh
        00301040 62              ??         62h    b
        00301041 00              ??         00h
        00301042 00              ??         00h
        00301043 00              ??         00h
        00301044 6c              ??         6Ch    l
        00301045 00              ??         00h
        00301046 00              ??         00h
        00301047 00              ??         00h
        00301048 72              ??         72h    r
        00301049 00              ??         00h
        0030104a 00              ??         00h
        0030104b 00              ??         00h
        0030104c ff              ??         FFh
        0030104d ff              ??         FFh
        0030104e ff              ??         FFh
        0030104f ff              ??         FFh
        00301050 ff              ??         FFh
        00301051 ff              ??         FFh
        00301052 ff              ??         FFh
        00301053 ff              ??         FFh
        00301054 ff              ??         FFh
        00301055 ff              ??         FFh
        00301056 ff              ??         FFh
        00301057 ff              ??         FFh
        00301058 ff              ??         FFh
        00301059 ff              ??         FFh
        0030105a ff              ??         FFh
        0030105b ff              ??         FFh
        0030105c ff              ??         FFh
        0030105d ff              ??         FFh
        0030105e ff              ??         FFh
        0030105f ff              ??         FFh
        00301060 ff              ??         FFh
        00301061 ff              ??         FFh
        00301062 ff              ??         FFh
        00301063 ff              ??         FFh
        00301064 61              ??         61h    a
        00301065 00              ??         00h
        00301066 00              ??         00h
        00301067 00              ??         00h
        00301068 65              ??         65h    e
        00301069 00              ??         00h
        0030106a 00              ??         00h
        0030106b 00              ??         00h
        0030106c 69              ??         69h    i
```

We can see the char ```f``` is stored at ```00301024```. This will output 1 since ```((0x00301024 - 0x00301020) / 4) = 1```. ```0x00301020``` is the start of the array. The second byte is ```0x9```, so the char that should correspond to it is ```(0x00301020 + (4*9)) = 0x301044``` and we can see that the character there is ```l```.

We move through the rest of the list to get the flag. So let's go grab our bytes from desiredOutput, removing the empty ones:
```
                             desiredOutput                                   XREF[2]:     main:0010096b(*), 
                                                                                          main:00100972(R)  
        003014e0 01              ??         01h
        003014e8 09              ??         09h
        003014f0 11              ??         11h
        003014f8 27              ??         27h    '
        00301500 02              ??         02h
        00301510 12              ??         12h
        00301518 03              ??         03h
        00301528 12              ??         12h
        00301530 09              ??         09h
        00301538 12              ??         12h
        00301540 11              ??         11h
        00301548 01              ??         01h
        00301550 03              ??         03h
        00301558 13              ??         13h
        00301560 04              ??         04h
        00301568 03              ??         03h
        00301570 05              ??         05h
        00301578 15              ??         15h
        00301580 2e              ??         2Eh    .
        00301588 0a              ??         0Ah
        00301590 03              ??         03h
        00301598 0a              ??         0Ah
        003015a0 12              ??         12h
        003015a8 03              ??         03h
        003015b0 01              ??         01h
        003015b8 2e              ??         2Eh    .
        003015c0 16              ??         16h
        003015c8 2e              ??         2Eh    .
        003015d0 0a              ??         0Ah
        003015d8 12              ??         12h
        003015e0 06              ??         06h
```

Each of these is set at an offset of 8 bytes. Now we need our lookup table:
```
                             lookup                                          XREF[6]:     transformFunc:00100820(*), 
                                                                                          transformFunc:00100827(R), 
                                                                                          transformFunc:00100844(*), 
                                                                                          transformFunc:0010084b(R), 
                                                                                          transformFunc:00100873(*), 
                                                                                          transformFunc:0010087a(R)  
        00301020 77              ??         77h    w
        00301024 66              ??         66h    f
        00301028 7b              ??         7Bh    {
        0030102c 5f              ??         5Fh    _
        00301030 6e              ??         6Eh    n
        00301034 79              ??         79h    y
        00301038 7d              ??         7Dh    }
        00301040 62              ??         62h    b
        00301044 6c              ??         6Ch    l
        00301048 72              ??         72h    r
        00301064 61              ??         61h    a
        00301068 65              ??         65h    e
        0030106c 69              ??         69h    i
        00301074 6f              ??         6Fh    o
        00301078 74              ??         74h    t
        003010bc 67              ??         67h    g
        003010d8 75              ??         75h    u
```

Now we continue the operations
```
((0x00301020 + (4*1)) = 0x00301024)  == f
((0x00301020 + (4*9)) = 0x00301044)  == l
((0x00301020 + (4*11)) = 0x00301064) == a
((0x00301020 + (4*27)) = 0x003010bc) == g
```

We can write a script to do this for us:
```python
#!/usr/bin/python


lookupTable = {
    hex(0x301020): "w",
    hex(0x301024): "f",
    hex(0x301028): "{",
    hex(0x30102c): "_",
    hex(0x301030): "n",
    hex(0x301034): "y",
    hex(0x301038): "}",
    hex(0x301040): "b",
    hex(0x301044): "l",
    hex(0x301048): "r",
    hex(0x301064): "a",
    hex(0x301068): "e",
    hex(0x30106c): "i",
    hex(0x301074): "o",
    hex(0x301078): "t",
    hex(0x3010bc): "g",
    hex(0x3010d8): "u"
}


desiredOutput = [
    0x01,
    0x09,
    0x11,
    0x27,
    0x02,
    0x00,
    0x12,
    0x03,
    0x08,
    0x12,
    0x09,
    0x12,
    0x11,
    0x01,
    0x03,
    0x13,
    0x04,
    0x03,
    0x05,
    0x15,
    0x2e,
    0x0a,
    0x03,
    0x0a,
    0x12,
    0x03,
    0x01,
    0x2e,
    0x16,
    0x2e,
    0x0a,
    0x12,
    0x06
]


for i in desiredOutput:
    print hex((i * 4  + 0x00301020)), lookupTable[hex((i * 4) + 0x00301020)]
```
The output:
```
$   python get-flag.py
0x301024 f
0x301044 l
0x301064 a
0x3010bc g
0x301028 {
0x301020 w
0x301068 e
0x30102c _
0x301040 b
0x301068 e
0x301044 l
0x301068 e
0x301064 a
0x301024 f
0x30102c _
0x30106c i
0x301030 n
0x30102c _
0x301034 y
0x301074 o
0x3010d8 u
0x301048 r
0x30102c _
0x301048 r
0x301068 e
0x30102c _
0x301024 f
0x3010d8 u
0x301078 t
0x3010d8 u
0x301048 r
0x301068 e
0x301038 }
```
