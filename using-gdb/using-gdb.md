# Using GDB

GDB stands for GNU Debugger. 

notes from [guyinatuxedo](https://guyinatuxedo.gihub.io/02-intro_tooling/deb-gef/index.html)
## gdb-gef

Gef is a wrapper for gdb that can be found on [github](https://github.com/hugsy/gef).

It can be installed with the following command:

```
wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh
```

## Using GDB

We will be using a very simple C program that prints the string "Hi".

```c
#include <stdio.h>
int main() {
   // printf() displays the string inside quotation
   printf("Hi");
   return 0;
}
```
It can be compiled with
```
gcc -o hi hi.c
```

Let's fire up gdb to look at hi and run it with **r**.

```
gdb ./hi
GNU gdb (Debian 9.1-3) 9.1
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
GEF for linux ready, type `gef' to start, `gef config' to configure
77 commands loaded for GDB 9.1 using Python engine 3.8
[*] 3 commands could not be loaded, run `gef missing` to know why.
Reading symbols from ./hi...
(No debugging symbols found in ./hi)
gef➤  r
Starting program: /root/github/binary-exploitation/using-gdb/hi 
Hi[Inferior 1 (process 599778) exited normally]
gef➤  
```

### Breakpoints

We can disassemble the main function with ```disas main```

```asm
gef➤  disas main
Dump of assembler code for function main:
   0x0000555555555135 <+0>:     push   rbp
   0x0000555555555136 <+1>:     mov    rbp,rsp
   0x0000555555555139 <+4>:     lea    rdi,[rip+0xec4]        # 0x555555556004
   0x0000555555555140 <+11>:    mov    eax,0x0
   0x0000555555555145 <+16>:    call   0x555555555030 <printf@plt>
   0x000055555555514a <+21>:    mov    eax,0x0
   0x000055555555514f <+26>:    pop    rbp
   0x0000555555555150 <+27>:    ret    
End of assembler dump.
```

If we wanted to break on the call ```printf``` we can do so by setting a breakpoint with **b** at the offset of the call

```
gef➤  b *main+16
Breakpoint 1 at 0x555555555145
```

or we can use a memory address:

```
gef➤  b *0x0000555555555145
Note: breakpoint 1 also set at pc 0x555555555145.
Breakpoint 2 at 0x555555555145
```

Now when we run the binary and tries to run that instruction, the process will pause and drop us into a debugger console

```
gef➤  r
Starting program: /root/github/binary-exploitation/using-gdb/hi

Breakpoint 1, 0x0000555555555145 in main ()
[ Legend: Modified register | Code | Heap | Stack | String ]
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x0
$rbx   : 0x0
$rcx   : 0x00007ffff7fac718  →  0x00007ffff7fae980  →  0x0000000000000000
$rdx   : 0x00007fffffffe7a8  →  0x00007fffffffeab5  →  "SHELL=/bin/bash"
$rsp   : 0x00007fffffffe6b0  →  0x0000555555555160  →  <__libc_csu_init+0> push r15
$rbp   : 0x00007fffffffe6b0  →  0x0000555555555160  →  <__libc_csu_init+0> push r15
$rsi   : 0x00007fffffffe798  →  0x00007fffffffea87  →  "/root/github/binary-exploitation/using-gdb/hi"
$rdi   : 0x0000555555556004  →  0x3b031b0100006948 ("Hi"?)
$rip   : 0x0000555555555145  →  <main+16> call 0x555555555030 <printf@plt>
$r8    : 0x0
$r9    : 0x00007ffff7fe3530  →  <_dl_fini+0> push rbp
$r10   : 0x00007ffff7f77a83  →  "__vdso_getcpu"
$r11   : 0x206
$r12   : 0x0000555555555050  →  <_start+0> xor ebp, ebp
$r13   : 0x00007fffffffe790  →  0x0000000000000001
$r14   : 0x0
$r15   : 0x0
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe6b0│+0x0000: 0x0000555555555160  →  <__libc_csu_init+0> push r15  ← $rsp, $rbp
0x00007fffffffe6b8│+0x0008: 0x00007ffff7e16e0b  →  <__libc_start_main+235> mov edi, eax
0x00007fffffffe6c0│+0x0010: 0x00007ffff7fa9618  →  0x00007ffff7e166f0  →  <init_cacheinfo+0> push r15
0x00007fffffffe6c8│+0x0018: 0x00007fffffffe798  →  0x00007fffffffea87  →  "/root/github/binary-exploitation/using-gdb/hi"
0x00007fffffffe6d0│+0x0020: 0x00000001f7f77a48
0x00007fffffffe6d8│+0x0028: 0x0000555555555135  →  <main+0> push rbp
0x00007fffffffe6e0│+0x0030: 0x0000000000000000
0x00007fffffffe6e8│+0x0038: 0x446e04494b5170ea
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x555555555136 <main+1>         mov    rbp, rsp
   0x555555555139 <main+4>         lea    rdi, [rip+0xec4]        # 0x555555556004
   0x555555555140 <main+11>        mov    eax, 0x0
 → 0x555555555145 <main+16>        call   0x555555555030 <printf@plt>
   ↳  0x555555555030 <printf@plt+0>   jmp    QWORD PTR [rip+0x2fe2]        # 0x555555558018 <printf@got.plt>
      0x555555555036 <printf@plt+6>   push   0x0
      0x55555555503b <printf@plt+11>  jmp    0x555555555020
      0x555555555040 <__cxa_finalize@plt+0> jmp    QWORD PTR [rip+0x2fb2]        # 0x555555557ff8
      0x555555555046 <__cxa_finalize@plt+6> xchg   ax, ax
      0x555555555048                  add    BYTE PTR [rax], al
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── arguments (guessed) ────
printf@plt (
   $rdi = 0x0000555555556004 → 0x3b031b0100006948 ("Hi"?)
)
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "hi", stopped 0x555555555145 in main (), reason: BREAKPOINT
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x555555555145 → main()
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤
```

To show all of the breakpoints:

```
gef➤  info breakpoints
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000555555555145 <main+16>
        breakpoint already hit 1 time
2       breakpoint     keep y   0x0000555555555145 <main+16>
        breakpoint already hit 1 time
gef➤  
```

To delete a breakpoint:

```
gef➤  delete 2
```

We can also set a breakpoint at a particular function call by name
```
gef➤  b *printf
Breakpoint 3 at 0x7ffff7e46440: file printf.c, line 28.
gef➤  r
Starting program: /root/github/binary-exploitation/using-gdb/hi

Breakpoint 1, 0x0000555555555145 in main ()
[ Legend: Modified register | Code | Heap | Stack | String ]
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x0
$rbx   : 0x0
$rcx   : 0x00007ffff7fac718  →  0x00007ffff7fae980  →  0x0000000000000000
$rdx   : 0x00007fffffffe7a8  →  0x00007fffffffeab5  →  "SHELL=/bin/bash"
$rsp   : 0x00007fffffffe6b0  →  0x0000555555555160  →  <__libc_csu_init+0> push r15
$rbp   : 0x00007fffffffe6b0  →  0x0000555555555160  →  <__libc_csu_init+0> push r15
$rsi   : 0x00007fffffffe798  →  0x00007fffffffea87  →  "/root/github/binary-exploitation/using-gdb/hi"
$rdi   : 0x0000555555556004  →  0x3b031b0100006948 ("Hi"?)
$rip   : 0x0000555555555145  →  <main+16> call 0x555555555030 <printf@plt>
$r8    : 0x0
$r9    : 0x00007ffff7fe3530  →  <_dl_fini+0> push rbp
$r10   : 0x00007ffff7f77a83  →  "__vdso_getcpu"
$r11   : 0x206
$r12   : 0x0000555555555050  →  <_start+0> xor ebp, ebp
$r13   : 0x00007fffffffe790  →  0x0000000000000001
$r14   : 0x0
$r15   : 0x0
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe6b0│+0x0000: 0x0000555555555160  →  <__libc_csu_init+0> push r15  ← $rsp, $rbp
0x00007fffffffe6b8│+0x0008: 0x00007ffff7e16e0b  →  <__libc_start_main+235> mov edi, eax
0x00007fffffffe6c0│+0x0010: 0x00007ffff7fa9618  →  0x00007ffff7e166f0  →  <init_cacheinfo+0> push r15
0x00007fffffffe6c8│+0x0018: 0x00007fffffffe798  →  0x00007fffffffea87  →  "/root/github/binary-exploitation/using-gdb/hi"
0x00007fffffffe6d0│+0x0020: 0x00000001f7f77a48
0x00007fffffffe6d8│+0x0028: 0x0000555555555135  →  <main+0> push rbp
0x00007fffffffe6e0│+0x0030: 0x0000000000000000
0x00007fffffffe6e8│+0x0038: 0x0f5912c0883bcdf1
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x555555555136 <main+1>         mov    rbp, rsp
   0x555555555139 <main+4>         lea    rdi, [rip+0xec4]        # 0x555555556004
   0x555555555140 <main+11>        mov    eax, 0x0
 → 0x555555555145 <main+16>        call   0x555555555030 <printf@plt>
   ↳  0x555555555030 <printf@plt+0>   jmp    QWORD PTR [rip+0x2fe2]        # 0x555555558018 <printf@got.plt>
      0x555555555036 <printf@plt+6>   push   0x0
      0x55555555503b <printf@plt+11>  jmp    0x555555555020
      0x555555555040 <__cxa_finalize@plt+0> jmp    QWORD PTR [rip+0x2fb2]        # 0x555555557ff8
      0x555555555046 <__cxa_finalize@plt+6> xchg   ax, ax
      0x555555555048                  add    BYTE PTR [rax], al
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── arguments (guessed) ────
printf@plt (
   $rdi = 0x0000555555556004 → 0x3b031b0100006948 ("Hi"?)
)
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "hi", stopped 0x555555555145 in main (), reason: BREAKPOINT
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x555555555145 → main()
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤
```

### Viewing Things

Once we are in the debugger, we can view things. Let's look at the ```rdi``` register
```
gef➤  p $rdi
$1 = 0x555555556004
```
We can see that ```rdi``` holds ```0x555555556004```. We can inspect further with **x/s**
```
gef➤  x/g 0x555555556004
0x555555556004: 0x3b031b0100006948
gef➤  x/s 0x555555556004
0x555555556004: "Hi"
```
We can view the contents of all of the registers:
```
gef➤  info registers
rax            0x0                 0x0
rbx            0x0                 0x0
rcx            0x7ffff7fac718      0x7ffff7fac718
rdx            0x7fffffffe7a8      0x7fffffffe7a8
rsi            0x7fffffffe798      0x7fffffffe798
rdi            0x555555556004      0x555555556004
rbp            0x7fffffffe6b0      0x7fffffffe6b0
rsp            0x7fffffffe6b0      0x7fffffffe6b0
r8             0x0                 0x0
r9             0x7ffff7fe3530      0x7ffff7fe3530
r10            0x7ffff7f77a83      0x7ffff7f77a83
r11            0x206               0x206
r12            0x555555555050      0x555555555050
r13            0x7fffffffe790      0x7fffffffe790
r14            0x0                 0x0
r15            0x0                 0x0
rip            0x555555555145      0x555555555145 <main+16>
eflags         0x246               [ PF ZF IF ]
cs             0x33                0x33
ss             0x2b                0x2b
ds             0x0                 0x0
es             0x0                 0x0
fs             0x0                 0x0
gs             0x0                 0x0
```
And we can view the stack frame
```
gef➤  info frame
Stack level 0, frame at 0x7fffffffe6c0:
 rip = 0x555555555145 in main; saved rip = 0x7ffff7e16e0b
 Arglist at 0x7fffffffe6b0, args: 
 Locals at 0x7fffffffe6b0, Previous frame's sp is 0x7fffffffe6c0
 Saved registers:
  rbp at 0x7fffffffe6b0, rip at 0x7fffffffe6b8
```

### Changing Values

If we want to change the value of the ```rdi``` register we can:
```
gef➤  p $rdi
$2 = 0x555555556004
gef➤  set $rdi = 0x0
gef➤  p $rdi
$3 = 0x0
```

If we want to jump directly to an instruction, we can:
```
gef➤  j *0x0000000000001145                                                                                                                                                                                       
Continuing at 0x1145.
```




