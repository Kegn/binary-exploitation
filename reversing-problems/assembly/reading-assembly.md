# Reading assembly

from : [guyinatuxedo](guyinatuxedo.github.io/01-intro_assembly/reversing_assembly/index.html)

## If-Then

```
objdump -D if_then -M intel | less
```

Looking into the object dump, we see the main funtion.

```asm
080483fb <main>:
 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]
 80483ff:       83 e4 f0                and    esp,0xfffffff0
 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048405:       55                      push   ebp
 8048406:       89 e5                   mov    ebp,esp
 8048408:       51                      push   ecx
 8048409:       83 ec 14                sub    esp,0x14
 804840c:       c7 45 f4 0a 00 00 00    mov    DWORD PTR [ebp-0xc],0xa
 8048413:       83 7d f4 0a             cmp    DWORD PTR [ebp-0xc],0xa
 8048417:       75 10                   jne    8048429 <main+0x2e>
 8048419:       83 ec 0c                sub    esp,0xc
 804841c:       68 c0 84 04 08          push   0x80484c0
 8048421:       e8 aa fe ff ff          call   80482d0 <puts@plt>
 8048426:       83 c4 10                add    esp,0x10
 8048429:       b8 00 00 00 00          mov    eax,0x0
 804842e:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]
 8048431:       c9                      leave  
 8048432:       8d 61 fc                lea    esp,[ecx-0x4]
 8048435:       c3                      ret    
 8048436:       66 90                   xchg   ax,ax
 8048438:       66 90                   xchg   ax,ax
 804843a:       66 90                   xchg   ax,ax
 804843c:       66 90                   xchg   ax,ax
 804843e:       66 90                   xchg   ax,ax
```

It moves the value 0xa into ebp-0xc

```asm
mov     DWORD PTR [rbp-0xc],0xa
```

Then it runs a cmp instruction to check if it is equal. 
If they are not equal it jumps to main+0x2e.
Because of the value it loaded, 0xa, it will not jump

```asm
cmp     DWORD PTR [ebp-0xc],0xa
jne     8048429 <main+0x2e>
```

We see it then makes a call to puts:

```
sub     esp,0xc
push    0x80484c0
call    80482d0 <puts@plt>
```

We see that the code should make a puts call. It does.
```
$   ./if_then
x = ten
```

## Loop

```
objdump -D loop -M intel | less
```

Looking at the objdump, we see the main function:

```asm
080483fb <main>:
 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]
 80483ff:       83 e4 f0                and    esp,0xfffffff0
 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048405:       55                      push   ebp
 8048406:       89 e5                   mov    ebp,esp
 8048408:       51                      push   ecx
 8048409:       83 ec 14                sub    esp,0x14
 804840c:       c7 45 f4 00 00 00 00    mov    DWORD PTR [ebp-0xc],0x0
 8048413:       eb 17                   jmp    804842c <main+0x31>
 8048415:       83 ec 08                sub    esp,0x8
 8048418:       ff 75 f4                push   DWORD PTR [ebp-0xc]
 804841b:       68 c0 84 04 08          push   0x80484c0
 8048420:       e8 ab fe ff ff          call   80482d0 <printf@plt>
 8048425:       83 c4 10                add    esp,0x10
 8048428:       83 45 f4 01             add    DWORD PTR [ebp-0xc],0x1
 804842c:       83 7d f4 13             cmp    DWORD PTR [ebp-0xc],0x13
 8048430:       7e e3                   jle    8048415 <main+0x1a>
 8048432:       b8 00 00 00 00          mov    eax,0x0
 8048437:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]
 804843a:       c9                      leave  
 804843b:       8d 61 fc                lea    esp,[ecx-0x4]
 804843e:       c3                      ret    
 804843f:       90                      nop
```

In the main, we see that it will initialize a variable at ebp-0xc to 0, then jump to 804842c (main+0x31)
```asm
mov     DWORD PTR [rbp-0xc],0x0
jmp     804842c <main+0x31>
```

Looking at 0x804842c we see:
```asm
cmp     DWORD PTR [ebp-0xc],0x13
jle    8048415 <main+0x1a>
```

It is comparing the stack value at ebp-0xc against 0x13 and if less than or equal, it will jump to 8048415 (0x80483fb \<main\> + 0x1a ).
This takes us to the printf call:
```asm
sub     esp,0x8
mov     DWORD PTR [ebp-0xc]
jmp     80482d0 <printf@plt>
```

It is printing out the contents of ebp-0xc in a format string. Then, it increments the value before doing cmp again
```asm
add DWORD PTR [ebp-0xc],0x1
```

Putting all of this together, we are looking at a for loop that will run 20 times and print the iteration counter each time.
```c
int i = 0;
for (i = 0; i < 20; i++)
{
    print("%d", i);
}
```

Running the binary:
```
$   ./loop
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
```


